# 云原生技术公开课
# 1. 元原生概念
## 1.1 不可变基础设施
- 传统的发布：ssh链接机器后，上传/修改文件
- 云原生：容器的发布和替换，原容器不再使用
## 1.2 云应用编排理论
- 如何构建自包含、可定制的应用镜像
- 能不能实现应用的快速部署和隔离能力
- 应用基础设施创建和销毁的自动化管理
- 可复制的管控系统和支撑组件
# 2. 容器基本概念
## 2.1 定义
一组进程的集合
## 2.2 特点
### 2.2.1 视图隔离
针对不同进程使用同一个文件系统所造成的问题而言，Linux 和 Unix 操作系统可以通过 chroot 系统调用将子目录变成根目录，达到视图级别的隔离；进程在 chroot 的帮助下可以具有独立的文件系统，对于这样的文件系统进行增删改查不会影响到其他进程
### 2.2.2 资源可限制
因为进程之间相互可见并且可以相互通信，使用 Namespace 技术来实现进程在资源的视图上进行隔离。在 chroot 和 Namespace 的帮助下，进程就能够运行在一个独立的环境下了
### 2.2.3 独立文件系统
但在独立的环境下，进程所使用的还是同一个操作系统的资源，一些进程可能会侵蚀掉整个系统的资源。为了减少进程彼此之间的影响，可以通过 Cgroup 来限制其资源使用率，设置其能够使用的 CPU 以及内存量
# 3. kubernetes核心概念
## 3.1 Pod
## 3.2 Volume
## 3.3 Deployment
## 3.4 Service
## 3.5 Namespace
# 4. Pod和容器设计模式
## 4.1 Pod
## 4.2 容器设计模式：sidecar
# 5. 应用编排和管理核心原理
## 5.1 kubernetes资源对象
- spec：期望的状态
- status：观测到的状态
- labels：识别资源的标签
- annotations：资源的注解
- owenReference：多个资源之间的相互关系
## 5.2 控制器模式
声明式API，而不是命令式API
# 6. Deployment
## 6.1 背景
pod管理面临的问题：
- 如何保证集群中pod可用的数量
- 如何为所有pod更新镜像版本
- 更新过程中，如果保证服务可用性
- 如何快速回滚
## 6.2 架构设计
Deployment只管理不同版本的ReplicaSet，由ReplicaSet来管理具体的Pod副本数，每个ReplicaSet对应Deployment template的一个版本。
# 7. Job和DaemonSet
## 7.2 Job
### 7.2.1 背景
- 我们如何保证 Pod 内进程正确的结束？
- 如何保证进程运行失败后重试？
- 如何管理多个任务，且任务之间有依赖关系？
- 如何并行地运行任务，并管理任务的队列大小？
## 7.4 DaemonSet
### 7.4.1 背景
- 首先如果希望每个节点都运行同样一个 pod 怎么办？
- 如果新节点加入集群的时候，想要立刻感知到它，然后去部署一个 pod，帮助我们初始化一些东西，这个需求如何做？
- 如果有节点退出的时候，希望对应的 pod 会被删除掉，应该怎么操作？
- 如果 pod 状态异常的时候，我们需要及时地监控这个节点异常，然后做一些监控或者汇报的一些动作，那么这些东西运用什么控制器来做？
# 8. 应用配置管理
## 8.1 背景
用一个容器镜像来启动一个 container，其实有很多需要配套的问题待解决：
- 比如说一些可变的配置。因为我们不可能把一些可变的配置写到镜像里面，当这个配置需要变化的时候，可能需要我们重新编译一次镜像，这个肯定是不能接受的；
- 一些敏感信息的存储和使用。比如说应用需要使用一些密码，或者用一些 token；
- 我们容器要访问集群自身。比如我要访问 kube-apiserver，那么本身就有一个身份认证的问题；
- 容器在节点上运行之后，它的资源需求；
- 容器在节点上，它们是共享内核的，那么它的一个安全管控怎么办？
- 容器启动之前的一个前置条件检验。比如说，一个容器启动之前，我可能要确认一下 DNS 服务是不是好用？又或者确认一下网络是不是联通的？那么这些其实就是一些前置的校验。
## 8.2 ConfigMap
## 8.3 Secret
## 8.4 SecretAccount
## 8.5 Resources
## 8.6 SecurityContext
## 8.7 InitContainers
